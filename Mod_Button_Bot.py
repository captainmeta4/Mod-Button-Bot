import praw
import time
from collections import deque
import re

#initialize reddit
r=praw.Reddit(user_agent="Toolbox Button Bot alpha /u/captainmeta4")

#set globals
username = "Mod_Button_Bot"
password = input("password: ")

permissions_fail = "I wasn't able to complete the requested action. I do not have the necessary moderator permissions."

cache = deque([],maxlen=1000) #cache of already-done items

#Cached dictionary of moderators in moderated subreddits
#Format is: {'subreddit1':[mod1,mod2],'subreddit2':[mod3,mod4]}
modlist = {} 

class Bot(object):

    def login_bot(self):

        print("logging in...")
        r.login(username, password)
        print("success")

    def do_comments(self):

        print("processing comments")
        for comment in r.get_comments("mod",limit=100):
            
            #avoid duplicate work
            if comment.id in cache:
                continue
            cache.append(comment.id)

            #check that user is moderator
            if comment.author.name not in modlist[comment.subreddit.display_name]:
                continue

            #remove totes_meta_bot posts that are generated by the bot's logging subreddit
            elif comment.author.name == "totes_meta_bot" and "[/r/Mod_Button_Bot_Log]" in comment.body:
                comment.remove
                continue
            
            print("processing comment "+comment.id)

            #enclose all mod actions in a big Try to protect against insufficient permissions
            try:
                if comment.body == "!ban":
                    parent_comment = r.get_info(thing_id=comment.parent_id)
                    comment.remove()
                    parent_comment.remove()
                    comment.subreddit.add_ban(parent_comment.author)
                    self.log_entry(comment.subreddit.display_name, comment.author, parent_comment.author, "ban", comment.permalink)

                if comment.body == "!unban":
                    parent_comment = r.get_info(thing_id=comment.parent_id)
                    comment.remove()
                    comment.subreddit.remove_ban(parent_comment.author)
                    self.log_entry(comment.subreddit.display_name, comment.author, parent_comment.author, "unban", comment.permalink)

                if "!flair" in comment.body:
                    parent_comment = r.get_info(thing_id=comment.parent_id)

                    #extract flair params
                    fclass = re.search("!flair( class=(\w+))? (.+)",comment.body).group(2)
                    ftext = re.search("!flair( class=(\w+))? (.+)",comment.body).group(3)
                    r.set_flair("mod_button_bot_log","captainmeta4",flair_text=ftext,flair_css_class=fclass)
                    self.log_entry(comment.subreddit.display_name, comment.author, parent_comment.author, "flair: "+str(ftext)+"/"+str(fclass), comment.permalink)

                if comment.body == "!approve":
                    parent_comment = r.get_info(thing_id=comment.parent_id)
                    comment.subreddit.add_contributor(parent_comment.author)
                    self.log_entry(comment.subreddit.display_name, comment.author, parent_comment.author, "approve", comment.permalink)

                if comment.body == "!unapprove":
                    parent_comment = r.get_info(thing_id=comment.parent_id)
                    comment.subreddit.remove_contributor(parent_comment.author)
                    self.log_entry(comment.subreddit.display_name, comment.author, parent_comment.author, "de-approve", comment.permalink)
                                   
                    
            except praw.errors.ModeratorOrScopeRequired:
                r.send_message(comment.author, "Error", comment.permalink+"\n\n"+permissions_fail)



                    
    def update_moderators(self):

        print("Updating all moderators")

        for subreddit in r.get_my_moderation():
            self.update_moderators_in_subreddit(subreddit)

    def update_moderators_in_subreddit(self, subreddit):

        mods=[]
        for user in subreddit.get_moderators():
            if user.name != "AutoModerator":     #ignore automod
                mods.append(user.name)
        modlist[subreddit.display_name]=mods
        print("moderators loaded for /r/"+subreddit.display_name)
            
    def check_messages(self):

        for message in r.get_unread(limit=None):

            message.mark_as_read()
            #Just assume all messages are a mod invite, and fetch modlist if invite accepted
            try:
                r.accept_moderator_invite(message.subreddit.display_name)
                print("Accepted moderator invite for /r/"+message.subreddit.display_name)
                self.update_moderators_in_subreddit(message.subreddit.display_name)            
            except:
                pass
    def log_entry(self, subname, modditor, redditor, action, url):
        #Post log entry to /r/mod_button_bot_log. Avoid duplicate submissions
        title = "[/r/"+subname+"] ["+action+"] /u/"+modditor.name+" --> /u/"+redditor.name
        try:
            r.get_subreddit("Mod_Button_Bot_Log").submit(title,url=url)
        except praw.errors.AlreadySubmitted:
            pass

modbot = Bot()

modbot.login_bot()

modbot.update_moderators()

while 1:
    print("running cycle")
    if time.localtime().tm_min==0 and time.localtime().tm_sec<30:
        modbot.update_moderators()
    modbot.check_messages()
    modbot.do_comments()
    print("sleeping for 30 seconds")
    time.sleep(1)
    while time.localtime().tm_sec != 0 and time.localtime().tm_sec != 30:
        time.sleep(1)
